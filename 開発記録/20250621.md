# 開発の記録
## ステップ１
`main.go` を `cmd/server/main.go` に置く構成ですね。Goプロジェクトでは **マルチパッケージ構成** をとることが多く、`cmd/server` は「実行バイナリのエントリーポイント」という意味で使われます。とても良い設計方針です。

---

## ✅ 想定するプロジェクト構成

```
/go-record-app2025
├── cmd/
│   └── server/
│       └── main.go      ← サーバー起動処理
├── templates/           ← HTMLテンプレート
│   └── goal_list.html
├── static/              ← 静的ファイル（画像など）
│   └── images/
│       ├── notStarted.svg
│       ├── activeGoals.svg
│       └── completedGoals.svg
├── go.mod
```

---

## ✅ ステップ1：`go.mod` 初期化（プロジェクトルートで）

```sh
cd /go-record-app2025
go mod init go-record-app2025
```

---

## ✅ ステップ2：`cmd/server/main.go` の中身

```go
package main

import (
	"html/template"
	"log"
	"net/http"
	"path/filepath"
)

func main() {
	// 静的ファイル (例: /static/images/xxx.svg)
	fs := http.FileServer(http.Dir("static"))
	http.Handle("/static/", http.StripPrefix("/static/", fs))

	// "/" にアクセスが来たら goal_list.html を返す
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		tmplPath := filepath.Join("templates", "goal_list.html")
		tmpl, err := template.ParseFiles(tmplPath)
		if err != nil {
			http.Error(w, "テンプレート読み込みエラー", http.StatusInternalServerError)
			log.Println("template error:", err)
			return
		}
		err = tmpl.Execute(w, nil)
		if err != nil {
			http.Error(w, "テンプレート描画エラー", http.StatusInternalServerError)
			log.Println("execute error:", err)
		}
	})

	log.Println("🚀 http://localhost:8080 でサーバー起動中")
	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		log.Fatal("サーバー起動失敗:", err)
	}
}
```

---

## ✅ ステップ3：サーバー起動

```sh
go run ./cmd/server
```

これで、`http://localhost:8080` にアクセスすると `goal_list.html` が表示され、CDN経由の Tailwind や `/static/images/` 配下の画像も使えるようになります。

---

## ✅ Tips：今後の拡張に備えて

この構成は、以下のような今後の分離にも対応しやすいです：

| ディレクトリ        | 内容                                   |
| ------------------- | -------------------------------------- |
| `cmd/server/`       | エントリーポイント                     |
| `internal/handler/` | HTTPハンドラ群（例：目標一覧取得など） |
| `internal/model/`   | データ構造やDBモデル                   |
| `templates/`        | HTMLテンプレート                       |
| `static/`           | CSS, JS, 画像など                      |

---

必要であれば、`internal/` や `pkg/` を使った分割構成や DI の設計も一緒にできます。
まずはこの `main.go` をベースに、ルーティング確認を進めてみましょう！

## ステップ2
素晴らしいスタートです！🎉
トップ画面 (`goal_list.html`) が正しく表示されていることを確認できたので、**次はサーバー側で「目標（Goal）」データを管理し、HTMLに動的に反映する仕組み**を導入していくステップになります。

---

## ✅ 今後のステップ（フェーズ1）

**静的HTML → 動的HTML（テンプレートレンダリング）** に進めていきましょう。

---

### ✅ ステップ 1：`Goal`構造体の作成

`main.go` に以下のような構造体を追加します：

```go
type Goal struct {
	ID          int
	Title       string
	Description string
	TargetDate  string
	Status      string // "NotStarted", "ActiveGoals", "CompletedGoals"
}
```

---

### ✅ ステップ 2：仮データを作成してテンプレートに渡す

```go
goals := []Goal{
	{ID: 1, Title: "Complete Data Science Course", TargetDate: "2024/08/15", Status: "NotStarted"},
	{ID: 2, Title: "Finish Golang API", TargetDate: "2024/08/20", Status: "ActiveGoals"},
	{ID: 3, Title: "Read Rust Book", TargetDate: "2024/07/10", Status: "CompletedGoals"},
}
```

これをテンプレートに渡すため、`tmpl.Execute(w, data)` の `data` に上記の `goals` を指定するようにします。

---

### ✅ ステップ 3：HTMLテンプレートに `range` で反映させる

`goal_list.html` の該当部分を以下のように動的に変更します：

```html
{{ range . }}
    {{ if eq .Status "NotStarted" }}
        <!-- Not Startedのカード表示 -->
    {{ else if eq .Status "ActiveGoals" }}
        <!-- Active Goalsのカード表示 -->
    {{ else if eq .Status "CompletedGoals" }}
        <!-- Completed Goalsのカード表示 -->
    {{ end }}
{{ end }}
```

---

### ✅ ステップ 4：テンプレート構造の整理（おすすめ）

今後複数ページを作るなら、以下のようにテンプレートを分割すると管理しやすくなります：

```
templates/
├── layout.html      ← ヘッダーや共通レイアウト
├── goal_list.html   ← コンテンツ部分だけ
```

`layout.html`：

```html
<!DOCTYPE html>
<html>
<head>
    <!-- ヘッダーやCSS読み込み -->
</head>
<body>
    {{ template "content" . }}
</body>
</html>
```

`goal_list.html`：

```html
{{ define "content" }}
    <!-- 目標リストのHTML -->
{{ end }}
```

Goコード側では以下のようにまとめて読み込みます：

```go
tmpl := template.Must(template.ParseFiles("templates/layout.html", "templates/goal_list.html"))
tmpl.Execute(w, data)
```

---

## ✅ 今後のロードマップ（フェーズ2以降）

| ステップ        | 内容                                           |
| --------------- | ---------------------------------------------- |
| DB接続          | PostgreSQLを接続し、`Goal`データをDBから取得   |
| 学習記録画面    | `StudyRecord`を追加・表示する画面を作成        |
| フォーム処理    | フロントからのフォーム投稿を受け取って保存処理 |
| REST API化      | JSONでやりとりするAPI化も段階的に対応可能      |
| 永続化 & テスト | Dockerでローカル環境のDBを構築／自動テスト導入 |

---

## 💡 今やるべきこと（まとめ）

* [ ] `Goal`構造体を作成
* [ ] 仮データを`[]Goal`として `tmpl.Execute(w, data)` に渡す
* [ ] `goal_list.html` を `{{range .}}` で動的描画対応に書き換え
* [ ] 必要に応じてテンプレートを `layout.html` で分割

---

準備ができたら、動的テンプレートの具体的な書き方やテンプレート分割のコードも提供できます！
進め方の希望や質問があれば、どんどん聞いてくださいね。
