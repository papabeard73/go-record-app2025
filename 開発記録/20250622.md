# 20250622 01

了解です！
ここからは **「ローカルに PostgreSQL を用意 → マイグレーションでテーブルを作成 → Go から接続」** までを、できるだけ“つまずきポイント”無しで進められるように手順化します。

---

## 0. 全体像（ゴール）

1. **Docker で PostgreSQL 起動**（Render でも同じバージョリを使えば本番にも転用しやすい）
2. **マイグレーションツール（`golang-migrate`）を導入**
3. **最初のマイグレーションを作成**（`users / goals / study_records`）
4. **Go で DB 接続コードを追加**
5. **静的 slice → DB から取得** に置き換え（一覧が DB データで表示されれば成功）

---

## 1. Docker で PostgreSQL を立てる

> プロジェクト直下に `docker-compose.yml` を置く方法が最も簡単です。

```yaml
version: "3.9"
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: appuser
      POSTGRES_PASSWORD: apppass
      POSTGRES_DB: goalsdb
    ports:
      - "5432:5432"
    volumes:
      - db-data:/var/lib/postgresql/data
volumes:
  db-data:
```

```bash
docker compose up -d
```

* **ホスト側ポート 5432** でつながります。
* ユーザー：`appuser` / パスワード：`apppass` / DB：`goalsdb`

---

## 2. マイグレーションツールを導入（golang-migrate 推奨）

```bash
# ツールをインストール（Go 1.20 以降）
go install github.com/golang-migrate/migrate/v4/cmd/migrate@latest
```

* `migrate` コマンドが `$GOPATH/bin` に入るので、PATH を通しておくと便利。

---

## 3. 最初のマイグレーションを作成

```bash
mkdir -p db/migrations
migrate create -ext sql -dir db/migrations -seq create_tables
```

### 生成されたファイル

```
db/migrations/
└── 000001_create_tables.up.sql
└── 000001_create_tables.down.sql
```

### `000001_create_tables.up.sql`

```sql
-- users（将来用）
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT UNIQUE,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- goals
CREATE TABLE IF NOT EXISTS goals (
    id SERIAL PRIMARY KEY,
    user_id INT REFERENCES users(id),
    title TEXT NOT NULL,
    description TEXT,
    status TEXT NOT NULL,
    target_date DATE,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- study_records
CREATE TABLE IF NOT EXISTS study_records (
    id SERIAL PRIMARY KEY,
    goal_id INT REFERENCES goals(id) ON DELETE CASCADE,
    content TEXT,
    duration_minutes INT NOT NULL,
    recorded_at DATE DEFAULT CURRENT_DATE
);
```

### `000001_create_tables.down.sql`

```sql
DROP TABLE IF EXISTS study_records;
DROP TABLE IF EXISTS goals;
DROP TABLE IF EXISTS users;
```

### 適用コマンド

```bash
migrate -database "postgres://appuser:apppass@localhost:5432/goalsdb?sslmode=disable" \
        -path db/migrations up
```

> **✔️ `success` が出れば OK**。テーブルが出来ているか psql や GUI クライアントで確認してみましょう。
>

> ✅ `migrate` の出力に `1/u create_tables` と出ているので、\*\*1個のマイグレーション（テーブル作成）\*\*が正常に適用されたことを意味しています。
では、**PostgreSQLに接続して本当にテーブルができているか確認**してみましょう。

---

## ✅ 方法1：`psql`（PostgreSQLのCLI）で確認

ターミナルで以下のようにしてログインします：

```bash
psql -U appuser -d goalsdb -h localhost -p 5432
```

* ユーザー名：`appuser`
* データベース名：`goalsdb`
* パスワード：`apppass`（入力を求められる）

**ログイン後：以下のSQLでテーブル一覧を確認**

```sql
\dt
```

出力例：

```
             List of relations
 Schema |     Name     | Type  |  Owner
--------+--------------+-------+----------
 public | goals        | table | appuser
 public | schema_migrations | table | appuser
```

* `goals`：自分が作ったテーブル（マイグレーションで作成されたもの）
* `schema_migrations`：`migrate` が管理用に自動作成するテーブル

終了するには：
```
\q
```
---

## ✅ 方法2：GUIツールで確認（PosticoやTablePlusなど）

PostgreSQLのGUIクライアントをお持ちなら、以下の情報で接続できます：

| 項目         | 値          |
| ------------ | ----------- |
| ホスト       | `localhost` |
| ポート       | `5432`      |
| ユーザー名   | `appuser`   |
| パスワード   | `apppass`   |
| データベース | `goalsdb`   |

ログイン後、**`goals` テーブルがあるかを探してください。**

---

## ❓補足：テーブルが見つからないとき

* マイグレーションSQLに `CREATE TABLE goals` が書かれているか？
* マイグレーション実行時のエラーがないか？
* 正しいデータベース (`goalsdb`) に接続しているか？

を確認してください。

---

必要なら、`db/migrations/xxxx_create_tables.up.sql` の内容も一緒に確認できますので、内容を共有してください！


---

## 4. Go から DB に接続する

### 4-1. ドライバを追加（`go-pg` でも `gorm` でも可だが、最軽量は `pgx + database/sql`）

```bash
go get github.com/jackc/pgx/v5
```

### 4-2. `internal/db/db.go` を作る（例）

```go
package db

import (
	"database/sql"
	"fmt"
	"log"
	"os"

	_ "github.com/jackc/pgx/v5/stdlib"
)

func Open() *sql.DB {
	dsn := fmt.Sprintf("postgres://%s:%s@%s:%s/%s?sslmode=disable",
		getenv("DB_USER", "appuser"),
		getenv("DB_PASSWORD", "apppass"),
		getenv("DB_HOST", "localhost"),
		getenv("DB_PORT", "5432"),
		getenv("DB_NAME", "goalsdb"),
	)

	db, err := sql.Open("pgx", dsn)
	if err != nil {
		log.Fatal("DB接続失敗:", err)
	}
	if err := db.Ping(); err != nil {
		log.Fatal("DB疎通失敗:", err)
	}
	return db
}

func getenv(k, def string) string {
	if v := os.Getenv(k); v != "" {
		return v
	}
	return def
}
```

### 4-3. main.go を修正して DB から取得

```go
import (
    "database/sql"
    // ...
)

func main() {
    db := db.Open()          // ← 先ほどの関数を呼ぶ
    defer db.Close()

    // 目標一覧取得クエリ
    rows, err := db.Query(`SELECT id, title, description, target_date, status FROM goals ORDER BY id`)
    if err != nil {
        log.Fatal("SELECT失敗:", err)
    }
    defer rows.Close()

    var goals []Goal
    for rows.Next() {
        var g Goal
        if err := rows.Scan(&g.ID, &g.Title, &g.Description, &g.TargetDate, &g.Status); err != nil {
            log.Fatal(err)
        }
        goals = append(goals, g)
    }

    // 以下は今までと同じ: goals をテンプレートに渡す
}
```

> **⚠️ 最初はテーブルが空なので、手動で `INSERT` して確認してみてください。**
>
> はい、PostgreSQL の `psql` にログインした状態で `INSERT` を実行する手順は以下の通りです。

---

### ✅ 前提

* `migrate` で作成されたテーブル名が `goals` であるとします（実際のテーブル名に合わせて調整してください）。
* カラムは例えば以下のように定義されていると仮定します：

```sql
CREATE TABLE goals (
    id SERIAL PRIMARY KEY,
    user_id INTEGER,
    title TEXT NOT NULL,
    description TEXT,
    target_date DATE,
    status TEXT NOT NULL
);
```

---

### 🧪 `psql` にログイン

```bash
psql -U appuser -d goalsdb -h localhost -p 5432
```

パスワードを求められたら `apppass` を入力。

---

### 📝 データを `INSERT`

ログイン後、次のような SQL を実行してください：

```sql
INSERT INTO goals (user_id, title, description, target_date, status)
VALUES (1, 'Go言語でWebアプリ作成', '学習管理アプリを作成する', '2025-08-15', 'ActiveGoals');
```

成功すれば次のような表示が出ます：

```
INSERT 0 1
```

---

### 📋 確認してみる

```sql
SELECT * FROM goals;
```

例：

```
 id | user_id |         title         |        description        | target_date |    status
----+---------+-----------------------+---------------------------+--------------+--------------
  1 |       1 | Go言語でWebアプリ作成 | 学習管理アプリを作成する  | 2025-08-15   | ActiveGoals
(1 row)
```

---

### 🚪 終了するには

```sql
\q
```

---

必要であれば、このデータを Go の `main.go` から取得してテンプレートに表示する方法も続けて案内できます！

このエラーは、`goals` テーブルの `user_id` に外部キー制約（foreign key constraint）が設定されており、参照先の `users` テーブルに `id = 1` のユーザーがまだ存在していないために発生しています。

---

## ✅ 解決手順

### 🔧 Step 1: `users` テーブルにユーザーを追加する

まず `users` テーブルに該当の `user_id` を持つレコードを追加しましょう。

```sql
INSERT INTO users (id, name, email)
VALUES (1, 'Eriko', 'eriko@example.com');
```

※ `users` テーブルの構造によって、必要なカラムを合わせてください。たとえば以下のような構造だと仮定します：

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    email TEXT NOT NULL UNIQUE
);
```

---

### 🔁 Step 2: 再度 `goals` テーブルに INSERT

今度は以下の SQL を再実行してみてください：

```sql
INSERT INTO goals (user_id, title, description, target_date, status)
VALUES (1, 'Go言語でWebアプリ作成', '学習管理アプリを作成する', '2025-08-15', 'ActiveGoals');
```

---

### 🧪 Step 3: 確認

```sql
SELECT * FROM goals;
```

---

## 📝 補足

このように外部キー制約は、データの整合性（存在しないユーザーに紐づくゴールが作られないように）を守るために便利ですが、テスト時は `users` に最低限のデータを用意しておくことが必要です。

必要であれば、開発用の初期データ（`seed`）を SQLファイルにまとめておくのも良い習慣です。希望があればその方法もお伝えできます。

開発時に毎回手動で `INSERT` を打つのは手間なので、**初期データ（seed）を SQL ファイルにまとめて管理**すると便利です。以下にその方法を解説します。

---

## ✅ 手順：開発用 seed データの管理方法

### ① `db/seeds/dev_seed.sql` を作成する

まず、以下のような SQL ファイルを作ります：

```
go-record-app2025/
└── db/
    └── seeds/
        └── dev_seed.sql
```

#### `dev_seed.sql` の内容例：

```sql
-- users テーブルの初期データ
INSERT INTO users (id, name, email) VALUES
  (1, 'Eriko', 'eriko@example.com'),
  (2, 'TestUser', 'test@example.com');

-- goals テーブルの初期データ
INSERT INTO goals (user_id, title, description, target_date, status) VALUES
  (1, 'Go言語でWebアプリ作成', '学習管理アプリを作成する', '2025-08-15', 'ActiveGoals'),
  (1, 'TOEIC 900点突破', '英語学習を継続して900点を超える', '2025-01-01', 'NotStarted'),
  (2, 'Reactでポートフォリオ作成', '就職活動用にReactアプリを作成する', '2025-03-31', 'CompletedGoals');
```

---

### ② psql で seed ファイルを流し込む

以下のコマンドで SQL を流し込みます：

```bash
psql -U appuser -d goalsdb -h localhost -p 5432 -f db/seeds/dev_seed.sql
```

※必要に応じてユーザー名やポート番号は修正してください。

---

## 🛠 ヒント：自動で初期化する方法も

開発のたびに seed を流すのが面倒な場合、以下のような工夫もできます：

* `Makefile` に登録して `make seed` で流せるようにする
* Docker 起動時に `init.sql` として自動で流す
* Go側に `seed.go` を用意して API or CLI から初期化できるようにする

---

## ✅ まとめ

| ステップ  | 内容                                  |
| --------- | ------------------------------------- |
| 1         | `db/seeds/dev_seed.sql` を作成        |
| 2         | `psql -f` コマンドで流し込む          |
| 3（任意） | Makefile や Go コードに組み込むと便利 |

---

希望があれば、Makefile や Go の `seed.go` 実装サンプルも提供できます。必要であれば教えてください！


---

## 5. うまく動いたら…

1. **フォームから INSERT** → 目標を追加
2. **一覧に即時反映** → テンプレートが DB データで動く
3. さらに **リポジトリ層**（`internal/repository/goal_repo.go`）を切るとテストしやすくなります。

---

### 参考：Render に持って行くとき

* Render の PostgreSQL アドオンか、無料の「Render PostgreSQL」サービスを追加
* 接続文字列は環境変数 `DATABASE_URL` に入るので、上記 `getenv` で読む
* `migrate` は Render の“スタートコマンド”に組み込むか、CI で実行

---

## ✨ まとめ

| ステップ             | コマンド例                                                      |
| -------------------- | --------------------------------------------------------------- |
| DB 起動              | `docker compose up -d`                                          |
| マイグレーション作成 | `migrate create -ext sql -dir db/migrations -seq create_tables` |
| マイグレーション適用 | `migrate -database postgres://... up`                           |
| Go ドライバ追加      | `go get github.com/jackc/pgx/v5`                                |
| 動作確認             | `go run ./cmd/server` → ブラウザで一覧が DB データになれば成功  |

---

ここまでできれば **「静的ダミーデータ → DB 永続データ」** への移行が完了です。
次はフォームから INSERT してみたり、`StudyRecord` を追加していく流れへ進めば OK です。

疑問点・エラーが出たときは遠慮なく聞いてください！

# 20250622 02

とても良い視点です！
「リポジトリ層を切るとテストしやすくなる」というのは、Goのアプリ設計で非常に重要な話です。

---

## ✅ 結論：なぜ「リポジトリ層」があるとテストしやすいのか？

> **理由：データ取得処理をインターフェースで抽象化できるから。**

これにより、

* **DB操作の本物の実装（PostgreSQLなど）** と
* **テスト用のモック（擬似DB）** を **簡単に入れ替えられる** ようになります。

---

## 💡 リポジトリ層が無い状態だと

たとえばコントローラーやサービス内で、こんなふうに直接SQLを使っていたとします：

```go
rows, err := db.Query("SELECT * FROM goals")
```

このようなコードは**DBがないとテストできません**。
ユニットテストをしようと思っても、実際にPostgreSQLが必要になってしまいます。

---

## ✅ リポジトリ層を切るとは？（構造）

### 1. インターフェースを定義

```go
// internal/repository/goal_repository.go

package repository

import "go-record-app2025/internal/model"

type GoalRepository interface {
	GetAllGoals() ([]model.Goal, error)
	GetGoalsByUserID(userID int) ([]model.Goal, error)
	// 他にも InsertGoal, UpdateGoal, DeleteGoal などを定義可能
}
```

### 2. 実装（PostgreSQLなど）

```go
// internal/repository/postgres_goal_repository.go

type postgresGoalRepo struct {
	DB *sql.DB
}

func (r *postgresGoalRepo) GetAllGoals() ([]model.Goal, error) {
	rows, err := r.DB.Query("SELECT id, title, target_date, status FROM goals")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var goals []model.Goal
	for rows.Next() {
		var g model.Goal
		err := rows.Scan(&g.ID, &g.Title, &g.TargetDate, &g.Status)
		if err != nil {
			return nil, err
		}
		goals = append(goals, g)
	}
	return goals, nil
}

func NewPostgresGoalRepo(db *sql.DB) GoalRepository {
	return &postgresGoalRepo{DB: db}
}
```

---

## ✅ テストがどう楽になるのか？

テストでは、この `GoalRepository` インターフェースを使って**モックを差し込む**だけ！

```go
type mockGoalRepo struct{}

func (m *mockGoalRepo) GetAllGoals() ([]model.Goal, error) {
	return []model.Goal{
		{ID: 1, Title: "モックの目標", Status: "NotStarted"},
	}, nil
}
```

そして、コントローラーやサービスのテストではこれを使います。

```go
repo := &mockGoalRepo{}
service := NewGoalService(repo) // ← 本物のDBじゃない

goals, _ := service.GetAllGoals()
fmt.Println(goals[0].Title) // => モックの目標
```

---

## ✅ まとめ

| 項目                         | 内容                                                                                    |
| ---------------------------- | --------------------------------------------------------------------------------------- |
| **リポジトリ層**とは         | DBアクセスのロジックを外部に切り出して、インターフェースで抽象化する層                  |
| **なぜテストしやすくなるか** | 本物のDBの代わりにモック（擬似実装）を渡せるから                                        |
| **実装の分離**               | PostgreSQL専用の実装は `postgres_goal_repository.go` などで書き、テストではモックを使う |

---

## ✨ 補足：今後の応用にも便利

* DBをPostgreSQL → MySQL に変えたくなっても、リポジトリ層を差し替えるだけで済みます。
* サービス層のテストで、DBの起動・初期化が不要になります。

---

もしご希望があれば、実際のファイル構成やテストコード例も一緒に提示できます！

もちろんです！
以下に、Goのクリーンアーキテクチャに基づいたファイル構成と、リポジトリ層を活かしたテストコード例をまとめます。

---

## ✅ 1. 想定ファイル構成

```
go-record-app2025/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── handler/               ← HTTPリクエスト処理
│   │   └── goal_handler.go
│   ├── repository/           ← DBアクセス（インターフェース + 実装）
│   │   ├── goal_repository.go
│   │   └── postgres_goal_repository.go
│   ├── service/              ← ビジネスロジック
│   │   └── goal_service.go
│   ├── model/                ← DBエンティティ or DTO
│   │   └── goal.go
│   └── test/                 ← テスト用モックやデータ
│       └── mock_goal_repository.go
├── db/
│   └── migrations/
│       └── ...
│   └── seeds/
│       └── ...
├── templates/
│   └── goal_list.html
│   └── layout.html
```

---

## ✅ 2. 各ファイルのポイント

### 📄 model/goal.go

```go
package model

type Goal struct {
	ID          int
	UserID      int
	Title       string
	Description string
	TargetDate  string
	Status      string // "NotStarted", "ActiveGoals", "CompletedGoals"
}
```

---

### 📄 repository/goal\_repository.go（インターフェース）

```go
package repository

import "go-record-app2025/internal/model"

type GoalRepository interface {
	GetAll() ([]model.Goal, error)
}
```

---

### 📄 repository/postgres\_goal\_repository.go（実装）

```go
package repository

import (
	"database/sql"
	"go-record-app2025/internal/model"
)

type PostgresGoalRepository struct {
	DB *sql.DB
}

func NewPostgresGoalRepository(db *sql.DB) GoalRepository {
	return &PostgresGoalRepository{DB: db}
}

func (r *PostgresGoalRepository) GetAll() ([]model.Goal, error) {
	rows, err := r.DB.Query("SELECT id, user_id, title, description, target_date, status FROM goals")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var goals []model.Goal
	for rows.Next() {
		var g model.Goal
		if err := rows.Scan(&g.ID, &g.UserID, &g.Title, &g.Description, &g.TargetDate, &g.Status); err != nil {
			return nil, err
		}
		goals = append(goals, g)
	}
	return goals, nil
}
```

---

### 📄 service/goal\_service.go

```go
package service

import (
	"go-record-app2025/internal/model"
	"go-record-app2025/internal/repository"
)

type GoalService struct {
	Repo repository.GoalRepository
}

func NewGoalService(repo repository.GoalRepository) *GoalService {
	return &GoalService{Repo: repo}
}

func (s *GoalService) GetGoals() ([]model.Goal, error) {
	return s.Repo.GetAll()
}
```

---

### 📄 handler/goal\_handler.go

```go
package handler

import (
	"html/template"
	"net/http"
	"go-record-app2025/internal/service"
)

type GoalHandler struct {
	GoalService *service.GoalService
}

func NewGoalHandler(goalService *service.GoalService) *GoalHandler {
	return &GoalHandler{GoalService: goalService}
}

func (h *GoalHandler) ListGoals(w http.ResponseWriter, r *http.Request) {
	goals, err := h.GoalService.GetGoals()
	if err != nil {
		http.Error(w, "データ取得失敗", http.StatusInternalServerError)
		return
	}

	tmpl := template.Must(template.New("layout.html").Funcs(template.FuncMap{
		"eq": func(a, b string) bool { return a == b },
	}).ParseFiles("templates/layout.html", "templates/goal_list.html"))

	tmpl.ExecuteTemplate(w, "layout.html", goals)
}
```

---

### 📄 cmd/server/main.go

```go
package main

import (
	"database/sql"
	"log"
	"net/http"

	_ "github.com/lib/pq"
	"go-record-app2025/internal/handler"
	"go-record-app2025/internal/repository"
	"go-record-app2025/internal/service"
)

func main() {
	db, err := sql.Open("postgres", "postgresql://appuser:apppass@localhost:5432/goalsdb?sslmode=disable")
	if err != nil {
		log.Fatal("DB接続失敗:", err)
	}
	defer db.Close()

	repo := repository.NewPostgresGoalRepository(db)
	svc := service.NewGoalService(repo)
	h := handler.NewGoalHandler(svc)

	http.HandleFunc("/", h.ListGoals)
	http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static"))))

	log.Println("🚀 http://localhost:8080")
	http.ListenAndServe(":8080", nil)
}
```

---

## ✅ 3. モックとテスト例

### 📄 test/mock\_goal\_repository.go

```go
package test

import "go-record-app2025/internal/model"

type MockGoalRepo struct{}

func (m *MockGoalRepo) GetAll() ([]model.Goal, error) {
	return []model.Goal{
		{ID: 1, Title: "モック目標", Status: "NotStarted"},
		{ID: 2, Title: "もう1つのモック", Status: "ActiveGoals"},
	}, nil
}
```

---

### 📄 service/goal\_service\_test.go

```go
package service_test

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"go-record-app2025/internal/service"
	"go-record-app2025/internal/test"
)

func TestGetGoals(t *testing.T) {
	mockRepo := &test.MockGoalRepo{}
	svc := service.NewGoalService(mockRepo)

	goals, err := svc.GetGoals()

	assert.NoError(t, err)
	assert.Len(t, goals, 2)
	assert.Equal(t, "モック目標", goals[0].Title)
}
```

---

## ✅ 必要なパッケージ

* PostgreSQLドライバ

  ```bash
  go get github.com/lib/pq
  ```
* テスト用ライブラリ（おすすめ）

  ```bash
  go get github.com/stretchr/testify
  ```

---

## 🔚 まとめ

| 層           | 役割                                     |
| ------------ | ---------------------------------------- |
| `repository` | DBに接続する実装と、抽象インターフェース |
| `service`    | ビジネスロジック（実装とテストの分離点） |
| `handler`    | HTTP層。テンプレート描画やルーティング   |
| `test`       | モックやユニットテスト                   |

---

必要であれば、\*\*モック生成ツール（GoMockやMockery）**の使い方もお伝えできます。
次は、**「目標の新規作成機能」\*\*を追加して、POSTリクエスト対応していくのがおすすめです！
